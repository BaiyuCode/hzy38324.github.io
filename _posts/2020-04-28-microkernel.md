---
layout:     post                    # 使用的布局（不需要改）
title:    微内核架构             # 标题 
subtitle:   #副标题
date:       2020-04-12              # 时间
author:     ZY                      # 作者
header-img: img/banner/20190128/alyssa-graham-1322772-unsplash.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习

---

保险公司

以保险公司为例。

保险索赔的规则往往很复杂，不同保险产品、不同地区的索赔规则可能都不一样。

举个例子，假设在纽约州（NY），汽车挡风玻璃被岩石击碎，是可以索赔的，但是在加利福尼亚州（CA）则不行。这时候如果直接把这个逻辑写到代码里去，就是这样：

```java
if (在纽约) {
   if (被岩石击碎)  {
       // 索赔...
   }
} else if (在加利福尼亚) {
    if (被岩石击碎)  {
       // 不索赔...
    }
}
```

而且保险规则可不只这一条，到时候写出来就是这样：

```java
if (在纽约) {
   if (被岩石击碎)  {
       // 索赔...
   }
   if (被陨石击碎)  {
       // 索赔...
   }
   if (被流星击碎)  {
       // 索赔...
   }
   // more and more...
} else if (在加利福尼亚) {
    if (被岩石击碎)  {
       // 不索赔...
    }
    if (被陨石击碎)  {
       // 不索赔...
    }
    if (被流星击碎)  {
       // 不索赔...
    }
    // more and more...
}
```

这时候就带来一个问题，如果把这些代码耦合到保险的核心系统中，那么每次修改规则，就都需要重新发布整个系统，甚至影响到整个系统。

于是我们把这些规则抽取出来，有个专门的地方去配置这些规则，在配置时对规则的正确性做好校验，然后保险系统去动态的读取这些规则（类似于动态配置）。

这样就解决了「耦合度高」的问题，但其实解耦的还不够彻底，因为不同州的规则还是放到一起的，而我们在索赔处理的时候，通常只需要加载一个州的索赔规则。

另外，如果后面新过来一个州，想使用我们的保险系统，那么如果让这个州，在不影响其他州的情况下，配置自己的索赔规则？

于是有了这样一套保险索赔规则的「微内核架构」：

img

简单说就是，中间的核心模块，处理保险索赔的基本业务逻辑，至于保险规则，则由每个州自己去实现，做成类似于插件的东西，可以被单独加载和移除，而不影响核心系统和其他插件。



Dubbo

dubbo 的微内核架构

> 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用。

Protocol + Invoker + Exporter 怎么实现最小粒度的 rpc 调用？



从核心层开始，把其他层，一一说开去。







操作系统

微内核架构的优缺点












