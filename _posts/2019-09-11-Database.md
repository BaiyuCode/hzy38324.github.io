---
layout:     post                    # 使用的布局（不需要改）
title:     数据库通论    # 标题 
subtitle:   #副标题
date:       2019-09-11              # 时间
author:     ZY                      # 作者
header-img: img/banner/20190128/miguel-angel-hernandez-1322895-unsplash.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 数据库
---

# 数据库 1.0 —— 自力更生

我们想做一个书籍检索的网站，把所有图书信息都放在 csv 文件中，

Book.csv ( title , author , year )

```
"Gone with the Wind","Margaret Mitchell",1936
"Hamlet","William Shakespeare",1602
"活着","余华",1993
"三体","刘慈欣",2006
```

这种存储方式，实现起来简单，似乎很完美。

接下来，我们要查询《三体》的作者，于是我们写了这段代码：

```
for line in file: 
  record = parse(line)
      if "三体" == record[0]: 
          print record[1]
```

一开始，我们的库数据量很少，查询《三体》只需要打开一个 csv 文件，遍历 4 行记录，后来，我们的网站用户量剧增，上面的图书也爆发式增长到百万级别，一个 csv 文件已经存储不下，而《三体》这本书，还是一直被我们压在了最下面，每次查找《三体》，我们都要花费大量的磁盘 IO，遍历百万行记录。

当然，你可以利用缓存来优化，但这种依赖外界的优化方案，都不能从根本上解决问题，一旦缓存失效，你还是得从茫茫书海中去查找。

**问题症结在于：数据没有无规律的。**

一旦数据没有规律，我们查找数据时，就只能靠蛮力去遍历。

所以，**让数据规律存储**，是优化这个文件系统的第一步。

# 数据库 2.0 —— 规律存储

**让数据有规律的存储，一旦数据有规律，我们就可以使用各种算法去高效地查找它们。**

让书籍，按照「字典排序」升序存储，于是我们可以进行「二分查找」，时间复杂度从 O(n) -> O(log2n)，缺点是每次插入都要排序；

让书籍，按照「Hash 表」的结构进行存储，于是我们可以进行「Hash 查找」，用空间换时间，时间复杂度 O(1)；

让书籍，按照「二叉树」的结果进行存储，于是我们可以进行「二叉查找」，时间复杂度 O(log2n)；

二叉树极端情况下会退化成 O(n)，于是有了「平衡二叉树」；

平衡二叉树终究还是“二叉”，只有两个子节点，一次从磁盘 load 的数据太少，于是有了可以有多于 2 个子节点的 B 树；

B 树找出来的数据，是无序的，如果你要求数据排好序返回，还要在内存手动排一次序，于是有了叶子节点是一个双向链表的 B+ 树；

……  

**看到没，不断规律化你的存储结构，你就能得到越来越牛逼的查找性能。**

当然你会发现，按照「作者」查询，我建一个 B+ 树，按照「年份」查询，我也建一个 B+ 树，这样每增加一个字段查询，我都要建一个 B+ 树，如果索引里面放的是全部数据的信息，那会很冗余、很占用空间；

于是我让每个 B+ 树只记录数据的唯一标识，按照索引找打数据的唯一标识后，再去 load 全量的数据。

这就是 Mysql 里面的「二级索引」和「聚簇索引」：

- 「二级索引」只存储对应字段和唯一标识，查找时利用「二级索引」，可以快速找到数据的「唯一标识」；

- 「聚簇索引」是数据实际存储的位置，它也是有序的，按照「唯一标识」有序存储；

- 所以你在「二级索引」里拿到「唯一标识」后，可以快速地在「聚簇索引」找到数据的位置，大大减少了磁盘 IO；

img（二级 -> 聚簇）

Mysql 有一句话，“索引即数据”，指的就是「聚簇索引」，当然，如果用到了「覆盖索引」，那「二级索引」也能提供数据。

**我们经常说，「索引」提高了查找性能，其实不完全正确。**

还是以 Mysql 为例，索引只是告诉了你数据的「唯一标识」，但是你还要拿着这个「唯一标识」去数据里查找，如果这些数据本身不是有序的，那你还是得找大半天。

这就像你在字典里查一个单词 incredible ，你在目录，也就是索引里，找到这个单词在第 256 页，然而，这本书在装订的时候，页面订乱了，不是按递增来装订的，完全无序，于是乎，就算你知道了 incredible 在第 256 页，你还是得海底捞针般的，把整本书翻一遍。

**「索引」仅仅帮助你快速找到数据的标识，辅之以「数据规律的存储」，才能「减少磁盘 IO」,才能「加速查询」：**

**索引 + 规律存储 = 快速查询**

不过对于 Mysql 来说，它的规律存储，是通过「聚簇索引」来实现的，所以说是「索引」让它查询变快也对。

而对于 Elasticsearch，它的索引是「倒排索引」，规律存储，用的是「顺序存储」：

img

这样一来，我们的文件系统，已经不再是单纯的文件，而可能是用各种数据结构进行索引和存储的数据。

**数据结构带来了规律存储，带来了快速查询，也带来了操作的复杂度。**

你再也不能随意插入数据，因为你要维护数据的规律性，不管你是顺序存储还是 B+ 树，都要找到正确的位置进行插入；

可能你还想做个缓存来进一步减少磁盘 IO，那你得维护好缓存的生命周期，等等 ……  

这么多复杂的逻辑，如果都要让用户感知到，自己手动操作，那使用成本太高，每次插入都要写一大段代码，于是我们要给用户提供简洁的操作方式。  

# 数据库 3.0 —— 简洁的操作方式

几乎你用过的所有数据库，都会提供让你很方便的操控它的方式。

像 Mysql、Oracle 等关系型数据库，操作它们的语言，都是 SQL（Structured Query Language，结构化查询语言），这个是结构化数据领域的通用语言，于是我们称之为 DSL（domain-specific language，领域特定语言）：

> INSERT INTO Customer (FirstName, LastName, City, Country, Phone) 
>
> VALUES ('Craig', 'Smith', 'New York', 'USA', 1-01-993 2800)

而像 redis，它也定义了自己的一套语言，但是它比较谦虚，自称为`Command`:

> redis> SET mykey "Hello"
> "OK"
> redis> GET mykey
> "Hello"

也有像 Elasticsearch 一样直接提供 Restful API的：

> curl -X GET "localhost:9200/twitter/_doc/0?_source=false&pretty"

DSL、Command、API，其实都是为了方便你使用，降低了你的使用成本，不至于插入个数据，都要写一堆代码。

但是对于你的学习成本，却不一定降低了，反之，可能加大了你的学习成本，因为它屏蔽了背后的实现细节。

看似简简单单的语句背后，触发的可能是一连串复杂的逻辑。

# 数据库 4.0 —— 高级功能

ACID、事务、分布式、备份、缓存、存储优化



# 所以数据库到底是什么？

中间件

数据库 L = 数据库 S + 数据库管理系统

选择哪个中间件，取决于你的使用场景；而选择哪种数据库，则取决于你对数据的使用场景



# 他们都是数据库



# 数据库分类及选择

网状、层次

最后为什么选择关系型

# 参考

- https://softwareengineering.stackexchange.com/questions/251832/when-is-an-api-considered-to-be-an-embedded-dsl